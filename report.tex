    %\documentclass[bigbox]{jarticle}
    \documentclass{jarticle}[11pt]
    %\documentstyle[bigbox,fancybox]{jarticle}
     
    % コマンドの定義
    %
    % コメントアウト用のコマンド
    %   複数行にまたがる記述をまとめてコメントアウトする際に利用できる
    %   \COMMENT{ .... } で .... の部分をコメントアウト
    \newcommand{\COMMENT}[1]{}
     
    % 以下は，表(srmmary.tex)で使用しているコマンド
    \newcommand{\lw}[1]{\smash{\lower2.ex\hbox{#1}}}
     
    % 図を参照するためのマクロ
    \newcommand{\figref}[1]{\makebox{図~\ref{#1}}}
     
    % 表を参照するためのマクロ
    \newcommand{\tabref}[1]{\makebox{表~\ref{#1}}}

    %% 使用しているパッケージ等があれば，宣言しておく
    \usepackage{ascmac}
    \usepackage{graphicx} 
    \usepackage{afterpage}
    % 以下のパラメータは，見易いように適宜調整する．
    \topmargin=-1cm
    \textheight=24cm
    \textwidth=15.5cm
    \oddsidemargin=-.2cm
    \evensidemargin=-.2cm
     
    \title{{\normalsize 情報工学実験C（ソフトウェア）報告書}\\
    (コンパイラ）\\
    } 
    \author{ 
      学生番号: 09429533 \\
      提出者: 高島和嗣
    }
    
    \date{
      提出日: 2020年 2月4日 (火) \\　%% <-- 提出日を記載のこと
      締切日: 2020年 2月4日 (火)
    }
    
    \begin{document}
    \maketitle
 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{実験の目的}
\begin{itemize}
\item \verb|yacc|，\verb|lex|というプログラムジェネレータを使ってプログラムを作成する．
\item コンパイラを作成することでプログラム言語で書かれたプログラムとアセンブリ言語との対応について深く理解する．
\item 木構造の取り扱いを理解し，木構造を用いてC言語をアセンブリ言語に変換するコード生成のプログラムを作成する．
\end{itemize}

 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{作成した言語の定義}
\begin{verbatim}
<プログラム> ::= <変数宣言部> <文集合>
<変数宣言部> ::= <宣言文> <変数宣言部> | <宣言文>
<宣言文> ::= define <識別子>; | array <識別子> [ <数> ];
<文集合> ::= 　<文> <文集合>| <文>
<文> ::= <代入文> | <ループ文> | <条件分岐文>
<代入文> ::= <識別子> = <算術式>; | <識別子> [ <数> ] = <算術式>;
<算術式> ::= <算術式> + <項> | <算術式> - <項> | <項>
<項> ::= <項> * <因子> | <項> / <因子> | <因子>
<因子> ::= <変数> | (<算術式>)
<変数> ::= <識別子> | <数> | <識別子> [ <数> ]
<ループ文> ::= while (<条件式>) { <文集合> }
<条件分岐文> ::= if (<条件式>) { <文集合> } 
| if (<条件式>) { <文集合> } {<else文>} { <文集合> } 
| if (<条件式>) { <文集合> } {<else if文>} { <文集合> } 
| if (<条件式>) { <文集合> } {<else if文>} {<else文>} { <文集合> } 
<else文> ::= else { <文集合> }
<else if文> ::= else if (<条件式>) { <文集合> } 
| else if (<条件式>) { <文集合> } {<else if文>}
<条件式> ::= <算術式> == <算術式> | <算術式> < <算術式> | <算術式> > <算術式> 
<識別子> ::= <英字> <英数字列> | <英字>
<英数字列> ::= <英数字> <英数字列>| <英数字>
<英数字> ::= <英字> | <数字>
<数> ::= <数字> <数> | <数字>
<英字> ::= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|A|B|C|D|E|F|G|H|I|J|K
|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
<数字> ::= 0|1|2|3|4|5|6|7|8|9
\end{verbatim}

 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{定義した言語で受理されるプログラムの例}
\begin{itemize}
\item 代入文
\begin{verbatim}
define a;
define b;

array n[3];

a=0; 
b=1;
n[0]=3;
n[1]=5;
n[2]=7;
\end{verbatim}

\item 算術式
\begin{verbatim}
define a;
define b;
array n[3];

a=0; 
b=1;
n[0]=3;
n[1]=5;
n[2]=7;

a=a+2;
b=a*n[0]-b;
n[0]=(n[0]+n[1])/2;
n[1]=n[2]%n[1];
\end{verbatim}

\item if文
\begin{verbatim}
define a;
define b;
define c;
define d;

a=3; 
b=5;

if(a==2){
    b=b+1;
}
else if(a<4){
    b=10;
}
else{
    b=0;
}
\end{verbatim}

\item ループ文
\begin{verbatim}
define a;
define b;
define c;
define i;

a=0; 
b=0;
c=0;
i=0;
while(i<6){
    a=b*2+c;
    i=i+1;
}
\end{verbatim}
\end{itemize}

 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{コード生成の概略}
\subsection{メモリの使い方}
テキストセグメント生成後に，コード末尾にデータセグメントを確保し，確保したデータセグメントに変数領域を記述した．
\subsection{レジスタの使い方}
スタックを用いて計算を行った．生成したコードの始めで，スタック領域を$32$バイト分確保し，\verb|$sp+20|のアドレスに元々の呼び出しアドレスを保存した．コードの終わりで，保存しておいた戻り値を復元し，スタックを開放した．

\subsection{算術式のコード生成の方法}
計算に用いる項が，変数ならばレジスタ\verb|$t0|にその変数のアドレスを入れ，\verb|lw|命令でそのアドレスの値を\verb|$v0|にロードし，ロードした値をスタックにストアし，実数ならばレジスタ\verb|$v0|にその値を入れ，値をスタックにストアした．この時，同じスタックに値を入れないように，ストアが終わった後にスタックの番号を次に進めておいた．
ストアしたスタックの値をそれぞれレジスタ\verb|$t0，$t1|にロードし，レジスタ\verb|$t0，$t1|を用いて算術し，得られた結果をスタックにストアした．

 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{工夫した点}
\verb|if|文の実装の際には，抽象構文木に\verb|if|のみの場合と\verb|if|と\verb|else|のみの場合と\verb|if|と\verb|elseif|のみの場合と\verb|if|と\verb|elseif|と\verb|else|の場合に分けて実装した．条件式を満たした時の処理が終了した後に他の条件式を満たしていても，その処理を行わずに処理を終了するように，\verb|if|文の処理部分でコードに関係しないラベル\verb|$D0|を\verb|if|文の処理の最後に設置しておき，条件式を満たしその処理を実行し終わった時は\verb|$D0|にジャンプするようにした．

\verb|elseif|を実装する時，\verb|elseif|が複数存在した場合には抽象構文木で\verb|elseif|の兄弟として扱おうとした．しかし，\verb|else|が存在する時，\verb|else|も同様に\verb|elseif|の兄弟として扱っていたため，探索が上手くいかなかった．そこで，\verb|elseif|を\verb|elseif|の子供として扱うようにし，\verb|else|の探索を行う前に\verb|elseif|の子供が存在しないかどうか確かめ，存在する場合は先にその処理を行うようにした．

条件式\verb|<=|を実装するために，まず\verb|'='|の判定をして条件を満たすなら\verb|while|の処理部分のラベルにジャンプし，条件を満たさない場合は次に\verb|'＜'|の判定をして条件を満たすなら\verb|while|の処理部分のラベルにジャンプするようにした．どちらの条件も満たさなかった場合は\verb|while|内の処理を行わないように\verb|while|の処理の後のラベルまでジャンプするようにした．

 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ソースプログラムのある場所}
\begin{verbatim}
/home/users/ecs/09429533/term3-4/compiler/lesson4/ast
\end{verbatim}

 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{最終課題を解くために書いたプログラムの概要}
\begin{itemize}
\item 最終課題$1$
\begin{verbatim}
define i;
define sum;

sum = 0;
i = 1;
while(i < 11) {
   sum = sum + i;
   i = i + 1;
}
\end{verbatim}

\item 最終課題$2$
\begin{verbatim}
define i;
define fact;

fact = 1;
i = 1;
while(i < 6) {
   fact = fact * i;
   i = i + 1;
}
\end{verbatim}

\item 最終課題$3$
\begin{verbatim}
 define fizz;
  define buzz;
  define fizzbuzz;
  define others;
  define i;

  fizz = 0; 
  buzz = 0;
  fizzbuzz = 0; 
  others = 0;
  i = 1;
  while(i < 31){
    if ((i / 15) * 15 == i){
      fizzbuzz = fizzbuzz + 1;
    }
    else if ((i / 3) * 3 == i){
      fizz = fizz + 1;
    }
    else if ((i / 5) * 5 == i){
      buzz = buzz + 1;
    }else{
      others = others + 1;
    }

    i = i + 1;
  }
\end{verbatim}

\item 最終課題$3$ (modを用いた場合)
\begin{verbatim}
define fizz;
define buzz;
define fizzbuzz;
define others;
define i;

fizz = 0; 
buzz = 0;
fizzbuzz = 0; 
others = 0;
i = 1;
while(i < 31){
    if (i % 15 == 0){
        fizzbuzz = fizzbuzz + 1;
    }
    else if (i % 3 == 0){
        fizz = fizz + 1;
    }
    else if (i % 5 == 0){
        buzz = buzz + 1;
    }else{
        others = others + 1;
    }    
    i = i + 1;
}
\end{verbatim}

\item 最終課題$4$ 
\begin{verbatim}
define N;
define i;
define n;
define k;
array a[1001];

N = 1000;
i = 1;
while (i <= N) {
      a[i] = 1;
      i = i + 1;
}

i = 2;
while( i <= N/2) {
       n = 2;
       while(n <= N/i){
       	       k = i * n;
               a[k] = 0;             	       
       	       n = n + 1;
       }
       i = i + 1;
}
\end{verbatim}
\end{itemize}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{最終課題の実行結果}
\begin{itemize}
\item 最終課題$1$
\begin{verbatim}
Stop at 0xfffffffc
508 instructions

 > print 0x10004000 0x10004001
0x10004000 (268451840) = 0x0000000b (11)
0x10004004 (268451844) = 0x00000037 (55)
0x10004008 (268451848) = 0x00000000 (0)
0x1000400c (268451852) = 0x00000000 (0)
0x10004010 (268451856) = 0x00000000 (0)
0x10004014 (268451860) = 0x00000000 (0)
0x10004018 (268451864) = 0x00000000 (0)
0x1000401c (268451868) = 0x00000000 (0)
0x10004020 (268451872) = 0x00000000 (0)
0x10004024 (268451876) = 0x00000000 (0)
0x10004028 (268451880) = 0x00000000 (0)
0x1000402c (268451884) = 0x00000000 (0)
0x10004030 (268451888) = 0x00000000 (0)
0x10004034 (268451892) = 0x00000000 (0)
0x10004038 (268451896) = 0x00000000 (0)
0x1000403c (268451900) = 0x00000000 (0)
\end{verbatim}

\item 最終課題$2$
\begin{verbatim}
Stop at 0xfffffffc
278 instructions

 > print 0x10004000 0x10004001
0x10004000 (268451840) = 0x00000006 (6)
0x10004004 (268451844) = 0x00000078 (120)
0x10004008 (268451848) = 0x00000000 (0)
0x1000400c (268451852) = 0x00000000 (0)
0x10004010 (268451856) = 0x00000000 (0)
0x10004014 (268451860) = 0x00000000 (0)
0x10004018 (268451864) = 0x00000000 (0)
0x1000401c (268451868) = 0x00000000 (0)
0x10004020 (268451872) = 0x00000000 (0)
0x10004024 (268451876) = 0x00000000 (0)
0x10004028 (268451880) = 0x00000000 (0)
0x1000402c (268451884) = 0x00000000 (0)
0x10004030 (268451888) = 0x00000000 (0)
0x10004034 (268451892) = 0x00000000 (0)
0x10004038 (268451896) = 0x00000000 (0)
0x1000403c (268451900) = 0x00000000 (0)
\end{verbatim}

\item 最終課題$3$
\begin{verbatim}
Stop at 0xfffffffc
3837 instructions

 > print 0x10004000 0x10004001
0x10004000 (268451840) = 0x00000008 (8)
0x10004004 (268451844) = 0x00000004 (4)
0x10004008 (268451848) = 0x00000002 (2)
0x1000400c (268451852) = 0x00000010 (16)
0x10004010 (268451856) = 0x0000001f (31)
0x10004014 (268451860) = 0x00000000 (0)
0x10004018 (268451864) = 0x00000000 (0)
0x1000401c (268451868) = 0x00000000 (0)
0x10004020 (268451872) = 0x00000000 (0)
0x10004024 (268451876) = 0x00000000 (0)
0x10004028 (268451880) = 0x00000000 (0)
0x1000402c (268451884) = 0x00000000 (0)
0x10004030 (268451888) = 0x00000000 (0)
0x10004034 (268451892) = 0x00000000 (0)
0x10004038 (268451896) = 0x00000000 (0)
0x1000403c (268451900) = 0x00000000 (0)
\end{verbatim}

\item 最終課題$3$(modを用いた場合)
\begin{verbatim}
Stop at 0xfffffffc
2979 instructions

 > print 0x10004000 0x10004001
0x10004000 (268451840) = 0x00000008 (8)
0x10004004 (268451844) = 0x00000004 (4)
0x10004008 (268451848) = 0x00000002 (2)
0x1000400c (268451852) = 0x00000010 (16)
0x10004010 (268451856) = 0x0000001f (31)
0x10004014 (268451860) = 0x00000000 (0)
0x10004018 (268451864) = 0x00000000 (0)
0x1000401c (268451868) = 0x00000000 (0)
0x10004020 (268451872) = 0x00000000 (0)
0x10004024 (268451876) = 0x00000000 (0)
0x10004028 (268451880) = 0x00000000 (0)
0x1000402c (268451884) = 0x00000000 (0)
0x10004030 (268451888) = 0x00000000 (0)
0x10004034 (268451892) = 0x00000000 (0)
0x10004038 (268451896) = 0x00000000 (0)
0x1000403c (268451900) = 0x00000000 (0)
\end{verbatim}

\item 最終課題$4$ \\
$1\sim11$までの測定結果のみ記載
\begin{verbatim}
Stop at 0xfffffffc
475386 instructions

 > print 0x10004000 0x10004004
0x10004000 (268451840) = 0x000003e8 (1000)
0x10004004 (268451844) = 0x000001f5 (501)
0x10004008 (268451848) = 0x00000003 (3)
0x1000400c (268451852) = 0x000003e8 (1000)
0x10004010 (268451856) = 0x00000000 (0)
0x10004014 (268451860) = 0x00000001 (1)
0x10004018 (268451864) = 0x00000001 (1)
0x1000401c (268451868) = 0x00000001 (1)
0x10004020 (268451872) = 0x00000000 (0)
0x10004024 (268451876) = 0x00000001 (1)
0x10004028 (268451880) = 0x00000000 (0)
0x1000402c (268451884) = 0x00000001 (1)
0x10004030 (268451888) = 0x00000000 (0)
0x10004034 (268451892) = 0x00000000 (0)
0x10004038 (268451896) = 0x00000000 (0)
0x1000403c (268451900) = 0x00000001 (1)
\end{verbatim}
\end{itemize}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{考察}
始め作成したプログラムは，最終課題$3$までのコンパイルは通ったが，ソケットを用いていないため，算術式の右辺の変数の数が$3$つ以上になるとレジスタの利用規則である\verb|$t9|を越えてしまい，計算出来なかった．\verb|$t0|と\verb|$t1|の算術結果を\verb|$t2|に入れていたため，オーバーしてしまったが，\verb|$t0|に入れるように変えたらオーバーせずに実行できると思ったが，その方法がソケットを用いる方法とほぼ同じであったため，今回はソケットを用いたプログラムに作り直した．

また，\verb|if|の中に\verb|if|文を入れたりジャンプするラベルの設定を変える必要がある．今回の実装では，\verb|if|文の中に\verb|if|文が入ることを想定せずに作成し，条件式を満たした後にジャンプする処理を\verb|AST_ELSE|と\verb|AST_ELSEIF|の処理の始めで書き込んでいるため，\verb|if|文の中に\verb|if|文が入る場合はジャンプの処理が書き込まれない．今回作成したプログラムでは\verb|if|文の条件を満たした時に実施する処理を\verb|printTree|関数で探索している途中で，その兄弟である\verb|else if|文や\verb|else|文も探索するような抽象構文木を作成しているため，適切な場所でジャンプ処理を行うために今回のように実装したが，\verb|if|文の中に\verb|if|文が入るならばジャンプ処理を\verb|IF|の処理の中に書く必要がある．実装するならば，抽象構文木を見直す可能性もあると思い，時間もなかったため今回は最終課題$4$までに対応したプログラムのままである．

今回はコードを実装するだけで，最適化を行えなかったので，もし行うなら不要な処理や\verb|nop|を削除したり，ループの最適化も行いたい．
\end{document}
